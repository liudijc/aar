
import chrome.app;
var app = chrome.app();
import thread.works;

var works = thread.works( 20,
	function(...) {
		import zmq;
		

		
		return "返回值,线程ID" + thread.getId();
	} ,obj
);

//分派任务
//works.push("一个任务") 





//chrome.app.path = "C:\Program Files (x86)\Google\Chrome\Application\chrome.exe"


/*
在下面的external对象中指定允许chrome中使用JS直接调用的函数
在网页中直接引用"/aardio.js"下面的external 会自动转换为js中的aardio对象.
"/aardio.js"是由 aardio虚拟的JS文件(不用自己准备这个文件)。
*/
app.external = {
    
    //加载一个页面完成会触发这个事件(要求引用了"/aardio.js")
    onLoadUrl = function(url){
        
        //接收js函数的返回值
		app.callback("hello",function(hSocket,result,err){
			//app.msgbox(result : err,"调用js的hello函数以后返回值了");
			 io.print("chrome调用了aardio函数",天气)
	    })

        //调用JS函数
        app.survey("hello","已经调用");
        
        //app.survey("kk2","aardio222");
    } 
    test = function(){
       //app.msgbox("chrome调用了aardio函数")
       io.print("chrome调用了aardio函数",天气)
       
    } 
    JSaardio = function(a){
       app.msgbox(a)
    } 
    works.push("一个任务") 

}

//WebSocke/RPC中遇到的错误都会触发这个函数,可以在这里自定义错误处理方式
app.ws.onError = function(hSocket,err){
	errput(err,"chrome/rpc error");//当然也可以在 global.onError 里自定义全部的错误信息怎么显示
}

//正式的启动chrome进程，aardio会自动把下面的文件转换为服务端请求
//app.start("/res/index.aardio");
app.start("/res/2.aardio");

//app.start("https://www.baidu.com/");

//网页中可以调用 aardio.quit() 退出,也可以直接关闭chrome窗口退出









win.loopMessage();







  